
/* Console controller - stops only
*  This structure accepts and reports MIDI messages. All vagaries relating to LED vs SAM are taken care of by microprocessors local to the LED or SAM.
*
* The stop action interface is a 10 pin multi-drop bus. The pinout is as follows:
*1- PeriphOut  2- MasterOut
*3-VCC   4-nRESET
*5-GND   6-SYNC_LOAD
*7-CLK   8-GND
*9-SAMPWR  10-SAMPWR
*PERIPHOUT - Output from peripheral to master. Pulled up hard (470 ohm). Peripheral uses open collector driver to indicate a 0, no drive or drive and release to indicate a 1. Multiple peripherals share this output.
*MASTEROUT - Output from master to peripheral. Always drive from master (SAMMidiProc
*SYNC/LOAD- A high to low transition indicates to every to reset counters. The next clock after Sync/Load goes to 0 is  the start of the read.write chain. Clock must be low on SYNC.
*CLOCK – Peripherals and master change data on rising edge, read data on falling edge. This clock will be no faster than 100KHz, high will be at least 5ms, low at least 5ms. Peripheral should respond within 3ms.

* There are 256 data bit slots. Bit 0 (least significant bit) is on the closest clock to the SYNC signal.
*
* This software instance provides the same timing on two different chains. The results are reported on different MIDI channels.
* The MIDI notes are spread across 2 channels.  So for chain 1, it's MIDIChannel and MIDIChannel+1;  For chain 2, it's MIDIChannel+2 and MIDIChannel+3
*
* The key action is an 8 pin daisy-chain interface.  It drives a shift register chain. There are 2 separate interfaces., each capable of 256 keys (4 manuals, or 3 manuals and pedal will fit in one interface).
* Pinout of the 8 pin interface is
* 1 – Input to shift chain (SER) 	2- Output from shift chain (nQH)
* 3 – VCC (3.3V)      				4- nRST (SRCLR)
* 5 – GND     						6 – LOAD (RCLK and G/OutputEnable)
* 7 – CLK (SRCLK)     				8 – GND
* Operation of the signals is governed by the component used: 74HC597 serial shift register, parallel input, serial output.
* The key channel 1 is MIDIChannel+4 and MIDIChannel+5
* The key channel 2 is MIDIChannel+6 and MIDIChannel+7
* 
* 
*/

#include <MIDI.h>
#include <EEPROM.h>
#include <Wire.h>
// TODO - Get both I2C functions working at the same time.
//#include <LCD_I2C_Teensy36.h>
//LCD_I2C_Teensy36 lcd(0x27,16,2);
#include <TimerOne.h>
//#include <Adafruit_MCP23017.h>
//Adafruit_MCP23017 mcp;

const int VersionNumberMajor=0;
const int VersionNumberMinor=0;
bool NoteInRetired=true;
int LEDStatus=22;
int MIDIChannel=5; //Must be 7 or less. Stored at EEPROM address 1.  EEPROM 0 validates write.  If 0xA5 then the EEPROM address is good.  EEPROM 2 stores PWM value. Flags stored EEPROM 3.
char Flags=0;
const char MIDILED=0;
// bit 0 - if 1, then LEDs are only controlled via MIDI commands (TODO)
// bit 1 - if 1, then initial LED state is not flashed
const int NoteBase=0;
// up const int NoteBase=51; // up

//HARDWARE CONFIG - For rev B board
//Input chain
const int SAMSense[2]={1,6};//Input from peripherals
const int SAMRst[2]={4,12};// Active low, pulled high
const int SAMSync[2]={2,10};// high to low resets for everyone
const int SAMCLK[2]={3,11};// 100KHz or less. clock high and then change data.  Read data after clock low.
const int SAMDrive[2]={0,5};//Output from this master

const int KeyIn[2]={25,36};
const int KeyOut[2]={24,35};
const int KeyRst[2]={29,39};
const int KeyLoad[2]={26,21};
const int KeyCLK[2]={28,20};
const int LCDAddress=0x27;
const int SAMDelay=4; //in loops
int SAMDelayCount=0;
bool SAMFlag=false;

// Analog
bool EnableAnalog=true;
const int SwitchInputs[]={A21,A22,A0,A1,A2,A3};
bool EnableSwitchExpression=false;
const int numAnalogChannels=1;
const int PedalCCValue[]={0x7,0x10, 0x11, 0x12, 0x13};
int PedalCurrentState[]={0,0,0,0,0};
int PedalAnalogChannel[]={A21,A22,A0,A1,A2,A3};
const int numBars=3;
const int AnalogChannelSegments[]={10,10,10,10,10};
const int AnalogDivisor=5;// number of shifts to the right (divs/2) to determine number of stages. 
int PedAveraging[8][5]={
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0}
};
int PedAvgCtr=0;
int AllSwells=0xFFFF; //if not FFFF, indicates control bit number which is the all swells to swell control, and if on, same data is sent on AllSwellsChannel
int AllSwellsChannel=0; //
bool AllSwellsChanged=false;
float BarValueF=0;

// End Analog



char LCDData[2][16]={{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}};
String myString="";
unsigned char LoopCounter=0;
bool LoopDone=false;
int keystate=0;
int EEValue;
bool HighConfigOn;
bool LowConfigOn;
bool ConfigState=false;

// The system supports 2 chains for SAMs and 2 chains for keys. Chains 0 and 1 are SAM chains (10 pin), and chains 2 and 3 are key chains (8 pin).
// In this implementation we will only implement one SAM chain (0) and one key chain (2).
unsigned int CurrentState[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
  }; //each scan chain is 256 bits, 4 unsigned chars per scan chain. Even high byte, odd low byte
unsigned int PreviousState[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
} ; //each scan chain is 64 bits, 4 unsigned chars per scan chain. Even high byte, odd low byte. 4 chains supported
unsigned int SAMState[2][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
}; // if a bit is set here, then the switch changed state
bool ChangedFlag=false;
unsigned int t32temp=0;
unsigned int tTempArray[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
  };
int BitCounter[]={0,0,0,0};
int WordCounter[]={0,0,0,0};

String tTempString="0000000000000000000000000000000000000000000000000000000000000000";
int ProcIndex=0;
int ProcBit=0;


int LoopDelay=100;
int test = 0;
const int MaxSAMChannels=0;
const int MaxKeyboards=0;// 4 keyboards = 256 bits.  max 8 keyboards = 512 bits.
const unsigned long bitTime=50;// in microseconds
const int frameTime=20000;// in microseconds



bool EnablePowerupLED=false;
bool PCMessageReceived=false;
const int PCMessageChannel = 1;
const int PCMessageNote=23;
int PCMessageLEDPort=6;
int PCMessageShutdownSwitch=5;
bool PCMessageShutdownSwitchPrevState=1;
bool PCMessageCurrentState=1; 
int SendNoteValue=0;


///////////////////////////Setup///////////////////////////

void setup() {
  usbMIDI.setHandleNoteOn(myNoteOn);
  usbMIDI.setHandleNoteOff(myNoteOff);
  Serial.begin(115200);
  Wire.begin();

  
  Serial.println("Setup scan chains...");
  for (int i=0;i<=1;i++){
    pinMode(SAMSense[i],INPUT_PULLUP);
    pinMode(SAMRst[i],INPUT_PULLUP);
    pinMode(SAMSync[i],OUTPUT);
    digitalWrite(SAMSync[i],LOW);
    pinMode(SAMCLK[i],OUTPUT);
    digitalWrite(SAMCLK[i],LOW);
    pinMode(SAMDrive[i],OUTPUT);
    digitalWrite(SAMDrive[i],LOW);
    
    pinMode(KeyIn[i],INPUT_PULLUP);
    pinMode(KeyOut[i],OUTPUT);
    digitalWrite(KeyOut[i],LOW);
    pinMode(KeyRst[i],OUTPUT);
    digitalWrite(KeyRst[i],HIGH);
    delay(1);
    digitalWrite(KeyRst[i],LOW);
    delay(1);
    digitalWrite(KeyRst[i],HIGH);
    pinMode(KeyLoad[i],OUTPUT);
    digitalWrite(KeyLoad[i],HIGH);
    pinMode(KeyCLK[i],OUTPUT);
    digitalWrite(KeyCLK[i],LOW);
 
  }// for i

  Serial.println("Setup Expression...");

  if (EnableSwitchExpression){
    for (int i=0;i<=5;i++){
      pinMode(SwitchInputs[i],INPUT_PULLUP);
    }
    Serial.println("Switch pullups set");
    int j=0;
    for (int i=0; i<=5;i++){
      if (digitalRead(SwitchInputs[i])==0) j+=0x10;
    }
    PedalCurrentState[0]=j;
  }//switch expression

//  mcp.begin();
  Serial.println("Setup Expression1..");
  if(numBars>1){
    for(int j=0;j<numBars;j++){
      for (int i=0;i<=AnalogChannelSegments[j];i++){
		  barOut(j,i);
        delay(30);
      }
    }// j - initialize bars
  }// if initialize bars
  Serial.println("Setup Expression2..");



  if (EnableAnalog){
    for (int i=0;i<numAnalogChannels;i++){
//      pinMode(PedalAnalogChannel[i],INPUT);
      pinMode(PedalAnalogChannel[i],INPUT_PULLUP);
      PedalCurrentState[i]=0;
      int l=analogRead(PedalAnalogChannel[i]);
      int j=l>>AnalogDivisor;
        if (PedalCurrentState[i]>=j){
          for (int k=PedalCurrentState[i]-1; k>=j; k--){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("AnalogValueDOWN");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }//for
        }//if
        else{
          for (int k=PedalCurrentState[i]+1; k<=j; k++){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("AnalogValueUP");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }
        }//else
        PedalCurrentState[i]=j;
        Serial.print("Current State ");
        Serial.print(i);
        Serial.print(": ");
        Serial.println(PedalCurrentState[i]);
        barOut(i,0);
        BarValueF=((float) l/(float) 0x3FF);
        if (BarValueF>=0.98) barOut(i,AnalogChannelSegments[i]);
        else barOut(i,(int) (BarValueF*((float) AnalogChannelSegments[i])));
        
    }//  for i, each analog channel
  }
    Serial.println("Setup Expression3..");

    Serial.println("Setup Database..");
    for (int i=0; i<=3; i++){
      for (int j=0; j<=15; j++){
        CurrentState[i][j]=0;
        PreviousState[i][j]=0;
      }
    }


/* PCMessage setup  
  pinMode(PCMessageLEDPort,OUTPUT);
  pinMode(PCMessageShutdownSwitch,INPUT_PULLUP);
*/
  pinMode(LEDStatus,OUTPUT);
  digitalWrite(LEDStatus,HIGH);

  Serial.println("Setup LCD...");
  initLCD();
  


  Serial.println("End Setup...");
  Serial.print("Version..");
  Serial.print(VersionNumberMajor,DEC);
  Serial.print(".");
  Serial.println(VersionNumberMinor,DEC);
  Timer1.initialize(frameTime); // 10ms loop time
  Timer1.attachInterrupt(restartLoop);
  Timer1.start();





}//setup


///////////////////////////////////main////////////////////////////

void loop() {
  LoopCounter++;
  digitalWrite(LEDStatus,bitRead(LoopCounter,4));
//  Serial.print(".");
//  if(LoopCounter==0) Serial.print(".");





//////////Scan data in

// clock period is 20us (50KHz).  256 bits is 5.12ms


// Start of sequence strobe

for (int i=0; i<=1; i++){
  digitalWrite(SAMSync[i],HIGH);
  digitalWrite(KeyLoad[i],LOW);
}
delayMicroseconds(bitTime+bitTime);
for (int i=0;i<=1;i++){
  digitalWrite(SAMSync[i],LOW);
  digitalWrite(KeyLoad[i],HIGH);
}
delayMicroseconds(bitTime+bitTime);

ChangedFlag=false;

for (int i=0;i<=3;i++){
  for (int j=0;j<=15;j++){
    if((CurrentState[i][j]^PreviousState[i][j])!=0) ChangedFlag=true;
  }
}

if (SAMDelayCount<=0xFC) SAMDelayCount++; 

if(SAMDelayCount<=SAMDelay) {Serial.print("SAM Delay ");Serial.println(SAMDelayCount,DEC);}


if(ChangedFlag){  
  Serial.print("ChangedState: Loop: ");
  Serial.println(LoopCounter,DEC);
  for (int j=0;j<=1;j++){
    Serial.print("MSW first PreviousState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(PreviousState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
  for (int j=0;j<=1;j++){
    Serial.print("MSW first CurrentState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(CurrentState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
}//changedflag



//if (SAMDelayCount>SAMDelay){ //Do nothing but syncs until the SAM is done.  TODO:  Need to change this to bring the keyboard stuff outside later
// The loop will output the current state to the SAMDrive, and input the peripheral state from the SAMSense and KeyIn lines 
//Serial.print("x");
for (int i=0;i<=255;i++){

  unsigned long time=micros();
  while(micros()>=(0xFFFFFFFF-(bitTime+10))){}// If there's less than 30us left on the timer, we'll wait for the timer rollover. This prevents from having to do rollover edge conditions

  for (int j=0;j<=1;j++){
//    if (SAMDelayCount>SAMDelay)
      digitalWrite(SAMDrive[j],bitRead(CurrentState[j][i>>4],(i&0xF)));
//    else
//      digitalWrite(SAMDrive[j],bitRead(PreviousState[j][i>>4],(i&0xF)));
    
    digitalWrite(KeyOut[j],bitRead(CurrentState[j+2][i>>4],(i&0xF)));
    digitalWrite(SAMCLK[j],HIGH);
    bitWrite(CurrentState[j+2][i>>4],i&0xF,digitalRead(KeyIn[j]));
    digitalWrite(KeyCLK[j],HIGH);
    }
  delayMicroseconds((bitTime/2));

  
  
  for (int j=0;j<=1;j++){
    digitalWrite(SAMCLK[j],LOW);
//    if (SAMDelayCount>SAMDelay)
    bitWrite(CurrentState[j][i>>4],i&0xF,!digitalRead(SAMSense[j]));//Negative logic, a 1 on the peripheral is inactive, 0 is active
  }//j
  
  while((micros()-time)<bitTime){}
}//i

//


for (int i=0;i<=255;i++){
  for (int j=0;j<=3;j++){
    int currentstateflag=bitRead(CurrentState[j][i>>4],i&0xF);
    int previousstateflag=bitRead(PreviousState[j][i>>4],i&0xF);
        if(currentstateflag!=previousstateflag){
          ChangedFlag=true;
          if(currentstateflag)  {
            usbMIDI.sendNoteOn(NoteBase+(i&0x7F),0x7F,MIDIChannel+2*j+(i&0x80>>7));
            Serial.print("Send ON: ");Serial.print(NoteBase+(i&0x7F),DEC);Serial.print(" ");Serial.println(MIDIChannel+2*j+(i&0x80>>7),DEC);
            } 
          else  {
              usbMIDI.sendNoteOff(NoteBase+(i&0x7F),0x7F,MIDIChannel+2*j+(i&0x80>>7));
              Serial.print("Send OFF: ");Serial.print(NoteBase+(i&0x7F),DEC);Serial.print(" ");Serial.println(MIDIChannel+2*j+(i&0x80>>7),DEC);
            }
      bitWrite(PreviousState[j][i>>4],i&0xF,currentstateflag);
      SAMDelayCount=0;
    }

  }//j
}//i

//}//if SamDelay Count



//////////////////////////////////// ANALOG CHANNELS ///////////////////////////////////////////////////////

/* Switch Expression
if (EnableSwitchExpression){
  int i=0;
  int j=0;
  for (int k=0; k<=5;k++){
    //debug
    pinMode(SwitchInputs[i],INPUT_PULLUP);
  //!debug
    if (digitalRead(SwitchInputs[k])==0) {j+=0x10; Serial.print("Switch number: ");Serial.println(k);}
  }
  if (j!=PedalCurrentState[i])
    {
      if (PedalCurrentState[i]>=j)
      {
        for (int k=PedalCurrentState[i]-1; k>=j; k--)
        {
          usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
    Serial.print("SwitchValue");
    Serial.println(j,HEX);
        }
      }
      else
      {
        for (int k=PedalCurrentState[i]+1; k<=j; k++)
        {
          usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
    Serial.print("SwitchValue");
    Serial.println(j);
        }
      }
      PedalCurrentState[i]=j;
      Serial.print("Current State ");
      Serial.print(i);
      Serial.print(": ");
      Serial.println(PedalCurrentState[i]);
    }
} //switch expression
*/




///////////////////////// Scan analog channels /////////////////////////////


  if (EnableAnalog){
    for (int i=0;i<numAnalogChannels;i++){
      int l=(analogRead(PedalAnalogChannel[i]));
      int j=l>>AnalogDivisor;
      if (j!=PedalCurrentState[i]){
        if (PedalCurrentState[i]>=j){
          for (int k=PedalCurrentState[i]-1; k>=j; k--){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("Pedal ");
            Serial.print(i);
            Serial.print(" AnalogValueDOWN");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }//for
        }//if
        else{
          for (int k=PedalCurrentState[i]+1; k<=j; k++){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("Pedal ");
            Serial.print(i);
            Serial.print(" AnalogValueUP");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }
        }//else
        PedalCurrentState[i]=j;
        Serial.print("Current State ");
        Serial.print(i);
        Serial.print(": ");
        Serial.println(PedalCurrentState[i]);

        BarValueF=((float) l/(float) 0x3FF);
        if (BarValueF>=0.98) barOut(i,AnalogChannelSegments[i]);
        else {
        barOut(i,(int) (BarValueF*((float) AnalogChannelSegments[i])));
        Serial.print("BarValue: ");
        Serial.print(BarValueF);
        Serial.println((int) BarValueF,DEC);
        Serial.print("BarValueint: ");
        Serial.print((int) (BarValueF*((float) AnalogChannelSegments[i])));
        }
      }// if j!=
    }//  for i, each analog channel
  }
////////////////////////////////analog channel/



/*  COMBINATION ACTION MEMORY STUFF
 *   
// if changed and mem+==0, memorylevel++ to 255
if ((bitRead(ChangedState[MemPlusButton>>4],MemPlusButton-(MemPlusButton>>4)*16)==1)&&(bitRead(CurrentState[MemPlusButton>>4],MemPlusButton-(MemPlusButton>>4)*16)==1)){
  if (CurrentMemoryNumber<=0xFE) CurrentMemoryNumber++;
}
// if changed and mem-==0, memorylevel-- to 0
if ((bitRead(ChangedState[MemMinusButton>>4],MemMinusButton-(MemMinusButton>>4)*16)==1)&&(bitRead(CurrentState[MemMinusButton>>4],MemMinusButton-(MemMinusButton>>4)*16)==1)){
  if (CurrentMemoryNumber>=1) CurrentMemoryNumber--;
}

// Note for Wicks, mem levels are absolute inputs
if ((bitRead(CurrentState[WicksLevel1>>4],WicksLevel1-(WicksLevel1>>4)*16)==1)) {CurrentMemoryNumber=0;}//Serial.println("Memory0");Serial.println(WicksLevel1>>4,HEX);Serial.println(WicksLevel1-(WicksLevel1>>4)*16,HEX);printint16(CurrentState[WicksLevel1>>4]);Serial.println("");}
if ((bitRead(CurrentState[WicksLevel2>>4],WicksLevel2-(WicksLevel2>>4)*16)==1)) {CurrentMemoryNumber=1;}//Serial.println("Memory1");}
if ((bitRead(CurrentState[WicksLevel3>>4],WicksLevel3-(WicksLevel3>>4)*16)==1)) {CurrentMemoryNumber=2;}//Serial.println("Memory2");}
if ((bitRead(CurrentState[WicksLevel4>>4],WicksLevel4-(WicksLevel4>>4)*16)==1)) {CurrentMemoryNumber=3;}//Serial.println("Memory3");}


// if changed and Piston[i], if set then write sense array & mask ELSE if exist read from memory and write to SAM
if ((bitRead(CurrentState[SetButton>>4],SetButton-(SetButton>>4)*16)==1)) {SetStatus=true;Serial.println("set");} else SetStatus=false; ///Note: SET is level, not edge sensitive


for (int i=0;i<=39;i++){
  if (Piston[i]!=0){
    ProcIndex=Piston[i]>>4;
    ProcBit=Piston[i]-(Piston[i]>>4)*16;
    if ((bitRead(ChangedState[ProcIndex],ProcBit)==1)&&(bitRead(CurrentState[ProcIndex],ProcBit)==1)){
      // generate filename
      Serial.print("pushed Piston ");Serial.println(i);
      String PistonFilename = "A00";//A for piston, 00 reserved.  
      if (CurrentMemoryNumber<=0xFF) PistonFilename=PistonFilename+"0";
      if (CurrentMemoryNumber<=0xF) PistonFilename=PistonFilename+"0";
      PistonFilename=PistonFilename+String(CurrentMemoryNumber,HEX);
	  Serial.print("Memory Level: ");Serial.println(CurrentMemoryNumber,HEX);
      if (i<=0xF) PistonFilename=PistonFilename+"0";
      PistonFilename=PistonFilename+String(i,HEX);
      Serial.print("PistonFilename: ");
      Serial.println(PistonFilename);
      
      // Create file if it doesn't exist
      if (!SD.exists(PistonFilename.c_str())){
        Serial.print("Create File "); Serial.println(PistonFilename);
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
        pistonFile.close();
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
//        pistonFile.print("0000000000000000000000000000000000000000000000000000000000000000");
        pistonFile.print("0000000000000000");
        pistonFile.close();
      }

      for (int j=0;j<=15;j++) OutputArray[j]=0;
      if (SetStatus){
        SD.remove(PistonFilename.c_str());
    		pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
        pistonFile.close();
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
		  
		// for 256,change to j<=7
        for (int j=0;j<=3;j++){
            Serial.print("BuildOutputArray " );Serial.print(i);Serial.println(j);printint16(CurrentState[j]);Serial.print("&");printint16(BitMask[i][j]);Serial.println("");
            OutputArray[j]=(CurrentState[j])&(BitMask[i][j]);//Stores 0's, which are active, as 1's 
            switch (OutputArray[j]){
              case 0:
                pistonFile.print("0000");Serial.print("0000");
                break;
              case 1 ... 0xF:
                pistonFile.print("000");pistonFile.print(OutputArray[j],HEX);Serial.print("000");Serial.print(OutputArray[j],HEX);
                break;
              case 0x10 ... 0xFF:
                pistonFile.print("00");pistonFile.print(OutputArray[j],HEX);Serial.print("00");Serial.print(OutputArray[j],HEX);
                break;
              case 0x100 ... 0xFFF:
                pistonFile.print("0");pistonFile.print(OutputArray[j],HEX);Serial.print("0");Serial.print(OutputArray[j],HEX);
                break;
              case 0x1000 ... 0xFFFF:
                pistonFile.print(OutputArray[j],HEX);Serial.print(OutputArray[j],HEX);
                break;
            }
            
            
//            pistonFile.print(OutputArray[j],HEX);
        }
        Serial.print("Set Piston[");Serial.print(i,DEC);Serial.print("]: ");for(int testi=0;testi<=7;testi++) printint16(OutputArray[testi]);Serial.println("");

       } //SetStatus
        else{
    			pistonFile=SD.open(PistonFilename.c_str());

		// read file, convert HEX to numbers and write to tTempArray[].  Build OutputArray[] and fire SAMs.
          tTempString="";
          while (pistonFile.available()) {
            switch (pistonFile.read()){
            case 48:
              tTempString=tTempString+"0";
              break;
            case 49:
              tTempString=tTempString+"1";
              break;
            case 50:
              tTempString=tTempString+"2";
              break;
            case 51:
              tTempString=tTempString+"3";
              break;
            case 52:
              tTempString=tTempString+"4";
              break;
            case 53:
              tTempString=tTempString+"5";
              break;
            case 54:
              tTempString=tTempString+"6";
              break;
            case 55:
              tTempString=tTempString+"7";
              break;
            case 56:
              tTempString=tTempString+"8";
              break;
            case 57:
              tTempString=tTempString+"9";
              break;
            case 65:
              tTempString=tTempString+"A";
              break;
            case 66:
              tTempString=tTempString+"B";
              break;
            case 67:
              tTempString=tTempString+"C";
              break;
            case 68:
              tTempString=tTempString+"D";
              break;
            case 69:
              tTempString=tTempString+"E";
              break;
            case 70:
              tTempString=tTempString+"F";
              break;
          }//switch
//          Serial.println(tTempString);
          }//while file
          Serial.print("String Read from ");Serial.print(pistonFile);Serial.print(": ");Serial.println(tTempString);
          for (int j=0;j<=3;j++) OutputArray[j]=0;
          for (int j=0;j<=3;j++){Serial.print("j=");Serial.print(j);Serial.print("::");
            tTempArray[j]=t16Stringtoint(tTempString.substring(j*4,j*4+4));
            Serial.print("tTempArray[");Serial.print(j,DEC);Serial.print("]: ");Serial.println(tTempArray[j],HEX);
            for (int k=0;k<=15;k++){
              // look for 16*j+k (the bit number) in sense array.  If it exists, and it is in the read piston string, use that index for ControlOn and ControlOff
              for (int m=0;m<=63;m++){
                if ((Sense[m]==(16*j+k))&&!(Sense[m]==0)) {
                  Serial.print("Sense[");Serial.print(m);Serial.print("] found ");Serial.print(Sense[m],HEX);//    
                  if (
				      (bitRead(tTempArray[Sense[m]>>4],(Sense[m]-((Sense[m]>>4)*16)))==1)
					  &&!(Piston[i]==GCButton)
					  )
                     {
                      bitWrite(OutputArray[ControlOn[m]>>4],(ControlOn[m])-(ControlOn[m]>>4)*16,1);
                     Serial.print(" On : ");Serial.println(ControlOn[m],HEX);
//                     Serial.print("writeHigh ControlOn[");Serial.print((16*j+k));Serial.print("]=");Serial.print(ControlOn[(16*j+k)]);Serial.print(" bit ");Serial.println((ControlOn[(16*j+k)]>>4)-(ControlOn[(16*j+k)]>>4)*16);
                     }  
                  else{
                    if(Piston[i]==GCButton) Serial.print("GC;");
                     bitWrite(OutputArray[ControlOff[m]>>4],(ControlOff[m])-(ControlOff[m]>>4)*16,1);
                     Serial.print(" Off: ");Serial.println(ControlOff[m],HEX);
//                     Serial.println("writeLow");
                  }

                }// if sense
               
              }// for m
                
              
            }// for k
          }// for J
          Serial.print("FireSAM Read Piston[");Serial.print(i,DEC);Serial.print("] OutputArray: ");for(int testi=3;testi>=0;testi--) printint16(OutputArray[testi]);Serial.println("");

          // fire SAMs
          pinMode(OutputSerialData,OUTPUT);
      		for (int j=0;j<=3;j++){
      			for (int k=15;k>=0;k--){
              if(bitRead(OutputArray[j],k)==1){
                digitalWrite(OutputSerialData,HIGH);
                Serial.print("1");
              }
                else {
                  digitalWrite(OutputSerialData,LOW);
                  Serial.print("0");
              }
              delayMicroseconds(1);
              digitalWrite(OutSerialClockPin,HIGH);
              delayMicroseconds(1);
              digitalWrite(OutSerialClockPin,LOW);
			      }// for k
		      }// for j
         Serial.println("");
         pinMode(OutLatchRegister,OUTPUT);
          digitalWrite(OutLatchRegister,HIGH);
          delayMicroseconds(2);
          digitalWrite(OutLatchRegister,LOW); // latch data into the output register

          
          delay(SAMDelay);

          Serial.println("Clear SAM");
          // clear everything 
          digitalWrite(OutputSerialData,LOW);
          for (int j=0;j<=3;j++){
            for (int k=0;k<=15;k++){
              delayMicroseconds(1);
              digitalWrite(OutSerialClockPin,HIGH);
              delayMicroseconds(1);
              digitalWrite(OutSerialClockPin,LOW);
            }// for k
          }// for j
          digitalWrite(OutLatchRegister,HIGH);
          delayMicroseconds(2);
          digitalWrite(OutLatchRegister,LOW); // latch data into the output register
         Serial.println("Cleared");



          
        
          // Light up LED pistons. This means doing the process again, but for Control On only, and when ControlLED=0

          for (int j=0;j<=3;j++){
            for (int k=0;k<=15;k++){
              // look for 16*j+k in sense array.  If it exists, use that index for ControlOn and ControlOff
              for (int m=0;m<=63;m++){
                if ((Sense[m]==16*j+k)&&!(Sense[m]==0)) {
                  if (bitRead(tTempArray[j],k)==1 && ControlLED[m]==true){
                     bitWrite(OutputArray[ControlOn[(16*j+k)>>4]],ControlOn[(16*j+k)>>4]-ControlOn[(16*j+k)>>4]*16,1);
                  }
                }// if sense
               
              }// for m
                
              
            }// for k
          }// for j          
          // At this point, OutputArray should only have 1's for LED outputs that are on.          
          for (int j=0;j<=3;j++){
            for (int k=0;k<=15;k++){
              if(bitRead(OutputArray[j],k)==1) digitalWrite(OutputSerialData,HIGH); else digitalWrite(OutputSerialData,LOW);
              digitalWrite(SerialClockPin,HIGH);
              delayMicroseconds(1);
              digitalWrite(SerialClockPin,LOW);
              delayMicroseconds(1);
            }// for k
          }// for j
          digitalWrite(OutLatchRegister,HIGH);
          delayMicroseconds(1);
          digitalWrite(OutLatchRegister,LOW); // latch data into the output register
          delayMicroseconds(1);
          digitalWrite(OutLatchRegister,HIGH);

          
        }//else set status
        pistonFile.close();

        
        
      }//if piston changed
    }//if piston !=0
  }//for i

*/ 
// END COMBINATION ACTION













 
    
//////////////////////////PCSwitch

  PCMessageCurrentState=digitalRead(PCMessageShutdownSwitch);   
  if (PCMessageCurrentState!=PCMessageShutdownSwitchPrevState){
    if (PCMessageCurrentState==0) usbMIDI.sendNoteOn(PCMessageNote,0x7F,PCMessageChannel); else usbMIDI.sendNoteOff(PCMessageNote,0x7F,PCMessageChannel);
    PCMessageShutdownSwitchPrevState=PCMessageCurrentState;
  }

  if(EnablePowerupLED){
    if(!PCMessageReceived)
      digitalWrite(PCMessageLEDPort,bitRead(LoopCounter,6));
    else
      digitalWrite(PCMessageLEDPort,1);
  
    
  }




















/////////////////////// Check for MIDI in


  
   while(usbMIDI.read()) {}; //Look for note on or off on our channel





//  delay(LoopDelay);
  LoopDone=true;
//  Serial.print(micros());
  while(IsLoopDone()){
    delay(1); //why adding this in makes it work is beyond me.
    }
    LoopDone=true;
  
}// void loop()



void printint16(unsigned int printvalue){
  if (printvalue<0xF) {Serial.print("000");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  if (printvalue<0xFF) {Serial.print("00");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  if (printvalue<0xFFF) {Serial.print("0");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  Serial.print(printvalue,HEX); Serial.print(" ");
  return;
  
}



void barOut(int address,int numsegments){
  int sendval=1;
  if (numsegments==0) {
    barSetup(address,0);
    return;
  }
  if (numsegments==1) 
    barSetup(address,1);
  else{
    for (int i=0;i<(numsegments-1);i++){
      sendval=(sendval<<1)|1;
    }
    barSetup(address,sendval);
  }
}

void barSetup(int address, int GPValue){
//  I2CWrite(address+0x20,0x15,0);// IOCON=0, Bank 0. Reset state is bank 0
  I2CWrite(address+0x20,0x0,0);// IODIRA=0, all outputs
  I2CWrite(address+0x20,0x1,0xFC);// IODIRB=FC, low 2 bits outputs
  I2CWrite(address+0x20,0x12,GPValue&0xFF);// GPIOA
  I2CWrite(address+0x20,0x13,GPValue>>8);// GPIO Bank0 = 0xFC -> Bits 0 and 1 outputs
}

void I2CWrite(int I2CAddress, int RegAddress, int Data){
  Wire.beginTransmission(I2CAddress);
  Wire.write(RegAddress); // IOCON
  Wire.write(Data); //IOCON=0
  Wire.endTransmission();
}


//////////////// LCD functions /////////////////////////////
void simpleI2CWrite(int I2CAddress, int Data){
  Wire.beginTransmission(I2CAddress);
  Wire.write(Data); 
  Wire.endTransmission();
}

void LCDI2CWrite(int I2CAddress, int Data, int RS, int RW){
/*  Serial.print("LCDI2CWrite Address:");
  Serial.print(I2CAddress,HEX);
  Serial.print(" Data:");
  Serial.print(Data,HEX);
  Serial.print(" RS:");
  Serial.print(RS,HEX);
  Serial.print(" RW:");
  Serial.println(RW,HEX);*/
  int SendData=(Data&0xF0)|RS|(RW<<1);
  simpleI2CWrite(I2CAddress,SendData);
  SendData=SendData|0xC;
  simpleI2CWrite(I2CAddress,SendData);
  SendData=SendData&0xFB;
  simpleI2CWrite(I2CAddress,SendData);
  delayMicroseconds(5);
  SendData=((Data&0xF)<<4)|RS|(RW<<1);// Lower nibble
  simpleI2CWrite(I2CAddress,SendData);
  SendData=SendData|0xC;
  simpleI2CWrite(I2CAddress,SendData);
  SendData=SendData&0xFB;
  simpleI2CWrite(I2CAddress,SendData);
  delayMicroseconds(4);  
}

char simpleI2CRead(int RS, int RW){
  int statusbyte=0;
  simpleI2CWrite(LCDAddress,0xF8|RS|(RW<<1));
  simpleI2CWrite(LCDAddress,0xFC|RS|(RW<<1));
  simpleI2CWrite(LCDAddress,0xF8|RS|(RW<<1));
  simpleI2CWrite(LCDAddress,0xFC|RS|(RW<<1));
  Wire.requestFrom(LCDAddress,1);
  while (!Wire.available()){}
  while (Wire.available()){
  statusbyte=Wire.read();
  }
  simpleI2CWrite(LCDAddress,0xF8|RS|(RW<<1));
  simpleI2CWrite(LCDAddress,0xFC|RS|(RW<<1));
  Wire.requestFrom(LCDAddress,1);
  while (!Wire.available()){}
  while (Wire.available()){
  statusbyte=statusbyte|(Wire.read()>>4);
  }
  simpleI2CWrite(LCDAddress,0xF8|RS|(RW<<1));
  return (char) statusbyte;
  
}


bool LCDStatus(){
//  Serial.print("Poll Busy");
  int statusbyte=0x80;
  statusbyte=simpleI2CRead(0,1);
//  Serial.print(" Status:");
//  Serial.println(statusbyte,HEX);
  if ((statusbyte&0x80)==0) return true; else return false;
}



void initLCD(){
  delay(80);
  int SendData=0x30;
  simpleI2CWrite(LCDAddress,SendData);
  SendData=SendData|0x4;
  simpleI2CWrite(LCDAddress,SendData);
  SendData=SendData&0xF3;
  simpleI2CWrite(LCDAddress,SendData);// Set 4 bit mode
  
  LCDI2CWrite(LCDAddress,0x28,0,0);
  delayMicroseconds(370);
  LCDI2CWrite(LCDAddress,0x28,0,0);
  delayMicroseconds(370);
  LCDI2CWrite(LCDAddress,0x0C,0,0);// on, no blink, no cursor
  while (!LCDStatus()) {}
  delayMicroseconds(370);
  LCDI2CWrite(LCDAddress,0x01,0,0);// Clear
  while (!LCDStatus()) {}
  delayMicroseconds(1820);
  LCDI2CWrite(LCDAddress,0x06,0,0);// entry mode increment by one
  while (!LCDStatus()) {}
  delayMicroseconds(370);

  myString="CR Control Sys...";
  LCDCursorHome(LCDAddress);
  LCDSetAddr(0,0);
  myString.toCharArray(LCDData[0],17);
  for (int i=0;i<=15; i++){
    Serial.println(LCDData[0][i]);
    LCDI2CWrite(LCDAddress,LCDData[0][i],1,0);
  while (!LCDStatus()) {}
  delayMicroseconds(40);
  }
//  Serial.println("secondline");
  myString="Chris Ballantyne  ";
  LCDCursorHome(LCDAddress);
  LCDSetAddr(1,0);
  myString.toCharArray(LCDData[1],17);
  for (int i=0;i<=15; i++){
  
    Serial.print(i);
    Serial.print(" : ");
    Serial.println(LCDData[1][i]);
    LCDI2CWrite(LCDAddress,LCDData[1][i],1,0);
  while (!LCDStatus()) {}
  delayMicroseconds(40);
  }
  
  
}

void LCDCursorHome(int I2CAddress){
  LCDI2CWrite(I2CAddress,2,0,0);
}

void LCDSetAddr(int row, int col){
  LCDI2CWrite(LCDAddress,(0x80|(row<<6)|col),0,0);//Set DDR address
  delayMicroseconds(10);
}



/* LCD Characters
 *  Space = -x20. 0-9=0x30-0x39. A-Z=0x41-0x5A - it is the ASCII chart
 */

///////////////////////////// END LCD FUNCTIONS/////////////////////////////


/*
void barOut(int address,int numsegments){
  if (numsegments==0) {
  for (int i=0;i<=9;i++) mcp.digitalWrite(i+address*8,LOW);
    return;
  }
  for (int i=0;i<numsegments;i++) mcp.digitalWrite(i+address*8,HIGH);   
  for (int i=numsegments;i<=numsegments;i++) mcp.digitalWrite(i+address*8,LOW);
}
*/

unsigned int t16Stringtoint(String inString){
  unsigned int ReturnValue=0;
  unsigned int AddValue=0;
  Serial.print("inString = ");Serial.println(inString);
  for (int qi=0; qi<=3; qi++){
    switch (inString.charAt(qi)){
      case '0':
        AddValue=0;
        break;
      case '1':
        AddValue=1;
        break;
      case '2':
        AddValue=2;
        break;
      case '3':
        AddValue=3;
        break;
      case '4':
        AddValue=4;
        break;
      case '5':
        AddValue=5;
        break;
      case '6':
        AddValue=6;
        break;
      case '7':
        AddValue=7;
        break;
      case '8':
        AddValue=8;
        break;
      case '9':
        AddValue=9;
        break;
      case 'A':
        AddValue=10;
        break;
      case 'B':
        AddValue=11;
        break;
      case 'C':
        AddValue=12;
        break;
      case 'D':
        AddValue=13;
        break;
      case 'E':
        AddValue=14;
        break;
      case 'F':
        AddValue=15;
        break;
        
    }//switch
    AddValue=AddValue<<(4*(3-qi));
    ReturnValue=ReturnValue|AddValue;
//    Serial.print(inString.charAt(qi));Serial.print(" ");Serial.print(qi);Serial.print(" "); Serial.println(ReturnValue,HEX);    
  }//for
  return ReturnValue;
}//function



void restartLoop(){
  LoopDone=false;
//  Serial.println(millis());
//  Serial.print("TimerDone ");
//  Serial.println(LoopDone);
}

bool IsLoopDone(){
  return LoopDone;
}
  
void myNoteOff(byte channel, byte note, byte velocity)
{
  Serial.print("External Note Off, ch=");
  Serial.print(channel, DEC);
  Serial.print(", note=");
  Serial.print(note, DEC);
  Serial.print(", velocity=");
  Serial.println(velocity, DEC);
  if((channel>=MIDIChannel)&&(channel<=(MIDIChannel+3)))
  {
    Serial.print("Message for me...LoopCount: ");
    Serial.println(LoopCounter,DEC);
    int index=(channel-MIDIChannel)>>1;
    int wordno=(((channel-MIDIChannel)&0x01)<<5)|((note&0x70)>>4);
    int bitno=note&0x0F;
    bitClear(CurrentState[index][wordno],bitno);
  }

}

void myNoteOn(byte channel, byte note, byte velocity) {
  Serial.print("ExternalNote On, ch=");
  Serial.print(channel, DEC);
  Serial.print(", note=");
  Serial.print(note, DEC);
  Serial.print(", velocity=");
  Serial.println(velocity, DEC);
  
  if((channel>=MIDIChannel)&&(channel<=(MIDIChannel+3)))
  {
    Serial.print("Message for me...LoopCount: ");
    Serial.println(LoopCounter,DEC);
    int index=(channel-MIDIChannel)>>1;
    int wordno=(((channel-MIDIChannel)&0x01)<<5)|((note&0x70)>>4);
    int bitno=note&0x0F;
    bitSet(CurrentState[index][wordno],bitno);
  }
  if(channel==PCMessageChannel){
    if (note==PCMessageNote) {PCMessageReceived=true;}  
  }
}
