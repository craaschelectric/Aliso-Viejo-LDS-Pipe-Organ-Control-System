

/* Console controller - stops only
*  This structure accepts and reports MIDI messages. All vagaries relating to LED vs SAM are taken care of by microprocessors local to the LED or SAM.
*
* The stop action interface is a 10 pin multi-drop bus. The pinout is as follows:
*1- PeriphOut  2- MasterOut
*3-VCC   4-nRESET
*5-GND   6-SYNC_LOAD
*7-CLK   8-GND
*9-SAMPWR  10-SAMPWR
*PERIPHOUT - Output from peripheral to master. Pulled up hard (470 ohm). Peripheral uses open collector driver to indicate a 0, no drive or drive and release to indicate a 1. Multiple peripherals share this output.
*MASTEROUT - Output from master to peripheral. Always drive from master (SAMMidiProc
*SYNC/LOAD- A high to low transition indicates to every to reset counters. The next clock after Sync/Load goes to 0 is  the start of the read.write chain. Clock must be low on SYNC.
*CLOCK – Peripherals and master change data on rising edge, read data on falling edge. This clock will be no faster than 100KHz, high will be at least 5ms, low at least 5ms. Peripheral should respond within 3ms.

* There are 256 data bit slots. Bit 0 (least significant bit) is on the closest clock to the SYNC signal.
*
* This software instance provides the same timing on two different chains. The results are reported on different MIDI channels.
* The MIDI notes are spread across 2 channels.  So for chain 1, it's MIDIChannel and MIDIChannel+1;  For chain 2, it's MIDIChannel+2 and MIDIChannel+3
*
* The key action is an 8 pin daisy-chain interface.  It drives a shift register chain. There are 2 separate interfaces., each capable of 256 keys (4 manuals, or 3 manuals and pedal will fit in one interface).
* Pinout of the 8 pin interface is
* 1 – Input to shift chain (SER) 	2- Output from shift chain (nQH)
* 3 – VCC (3.3V)      				4- nRST (SRCLR)
* 5 – GND     						6 – LOAD (RCLK and G/OutputEnable)
* 7 – CLK (SRCLK)     				8 – GND
* Operation of the signals is governed by the component used: 74HC597 serial shift register, parallel input, serial output.
* The key channel 1 is MIDIChannel+4 and MIDIChannel+5
* The key channel 2 is MIDIChannel+6 and MIDIChannel+7
* 
* 
*/


 /* General CA inputs are 
  *   G.C.
  *   Stop sense lines
  * Combination inputs are
  *   SET
  *   MEM+
  *   MEM-
  *   Crescendo
  *   Prev
  *   Next
  * 
  * SD card format is as follows
  * File names for each memory is Allnnnmm.mem.  Leading 0's.  l=expansion nnn=memory level, mmm=piston number.  In hex.
  * The bit fields are loaded for the piston pressed when pressed. 
  * A prefix is for this revision which has 256 bit (16 word) stop fields.  It uses only SAMCHAIN1 (index 0)
  * All pistons can do anything.
  * Effect masks are in ROM
  * 
  * 
  * Crescendo is XCnnmmmm.CRE  nn=crescendo number, mmmm=stage number.  The field is accessed from the SD card as the crescendo pedal is changed and applied to the stops
  * 
  * INITIAL INSTANCE - ONLY SUPPORT 64bits
  */

#include <MIDI.h>
#include <EEPROM.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd=LiquidCrystal_I2C(0x27,16,2);
#include <TimerOne.h>
#include <SD.h>
#include <SPI.h>

File pistonFile;
const int chipSelect=BUILTIN_SDCARD;

const int VersionNumberMajor=0;
const int VersionNumberMinor=0;
int LEDStatus=22;
int MIDIChannel=5; //Must be 7 or less. Stored at EEPROM address 1.  EEPROM 0 validates write.  If 0xA5 then the EEPROM address is good.  EEPROM 2 stores PWM value. Flags stored EEPROM 3.
const int NoteBase=0;

//HARDWARE CONFIG - For rev B board
//Input chain
const int SAMSense[2]={6,1};//Input from peripherals
const int SAMRst[2]={12,4};// Active low, pulled high
const int SAMSync[2]={10,2};// high to low resets for everyone
const int SAMCLK[2]={11,3};// 100KHz or less. clock high and then change data.  Read data after clock low.
const int SAMDrive[2]={5,0};//Output from this master

const int KeyOut[2]={25,36};
const int KeyIn[2]={24,35};
const int KeyRst[2]={29,39};
const int KeyLoad[2]={26,21};
const int KeyCLK[2]={28,20};
const int LCDAddress=0x27;
const int SAMDelay=3; //in loops, has to match microcontroller, not less than 3. TODO - Could reduce this if in UC latch output on 256th clock.
int SAMDelayCount=0;
bool SAMFlag=false;

// Analog
bool EnableAnalog=true;
const int SwitchInputs[]={A21,A22,A0,A1,A2,A3};
bool EnableSwitchExpression=false;
const int numAnalogChannels=1;
const int PedalCCValue[]={0x7,0x10, 0x11, 0x12, 0x13};
int PedalCurrentState[]={0,0,0,0,0};
int PedalAnalogChannel[]={A21,A22,A0,A1,A2,A3};
const int numBars=3;
const int AnalogChannelSegments[]={10,10,10,10,10};
const int AnalogDivisor=5;// number of shifts to the right (divs/2) to determine number of stages. 
int PedAveraging[8][5]={
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0},
  {0,0,0,0,0}
};
int PedAvgCtr=0;
int AllSwells=0xFFFF; //if not FFFF, indicates control bit number which is the all swells to swell control, and if on, same data is sent on AllSwellsChannel. 0-03FF
int AllSwellsChannel=0; //
bool AllSwellsChanged=false;
float BarValueF=0;

// End Analog



char LCDData[2][16]={{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}};
String myString="";
unsigned char LoopCounter=0;
bool LoopDone=false;
int keystate=0;
int EEValue;
bool HighConfigOn;
bool LowConfigOn;
bool ConfigState=false;


// CA constants and variables
const bool SAMChainsSupported=1; // For this implementation, we will only support one chain of 255 (SAM Chain 1 = index 0)
const int NextButton[4] = {0,0,0,0};  // this is the bit number in the scan chain, 0-3FF as with pistons
const int PrevButton[4] = {0,0,0,0};
const int GCButton = 0x209;
const int SetButton = 0x208;
bool SetState=false;
bool GCState=false;
bool PistonChangedFlag=false;
bool SpecialPistonState=false;
const int MemPlusButton = 0;
const int MemMinusButton = 0;
const int MemPlusButton2 = 0;
const int MemMinusButton2 = 0;
int CurrentPistonNumber= 0;//used with prev/next 
const int MaxPistonNumber= 0;//used with prev/next
int CurrentMemoryNumber= 0;//used with prev/next
String tTempString="0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF";
int ProcIndex=0;
int ProcBit=0;
int ProcArray=0;
int PressedPiston=0;
bool NewPistonSet=false;


// specifies input number (0-FE)  which is the sense line. 0xFF means not enabled. Look at PreviousState/CurrentState. First nibble is word number, starting at 0 on the Right. Second nibble is bit number
// ChangedState MSW first: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0100 0000   In this example, it is 0x19
// ChangedState MSW first: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 4000 0000 0000   In this example, it is 0x2E.  This value goes in the 


//40 pistons - define which input controls each (0-3FF), 400 = not used. Third nibble is which chain 2=KCH1, 3=KCH2, 0=SAMCH1, 1=SAMCH2  
const int Piston[40]={0x20A,0x20C,0x20E,0x20F,0x20D,0x20B,0x400,0x400, 0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400, 0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400, 0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400, 0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400};
const int SequencerPistonList[20]={0,1,2,3, 4,5,6,7, 0,0,0,0, 0,0,0,0, 0,0,0,0};  // This is an index into Generals 1-xx, xx<=20, It tells what number in the Piston[] list the general is. 
const char PistonName[40][6]={
  {"GEN01"},
  {"GEN02"},
  {"GEN03"},
  {"GEN04"},
  {"GEN05"},
  {"GEN06"},
  {"GEN07"},
  {"GEN08"},
  {"GEN09"},
  {"GEN10"},
  {"GEN11"},
  {"GEN12"},
  {"GEN13"},
  {"GEN14"},
  {"GEN15"},
  {"GEN16"},
  {"GEN17"},
  {"GEN18"},
  {"GEN19"},
  {"GEN20"},

  {"GT1  "},
  {"GT2  "},
  {"GT3  "},
  {"GT4  "},
  {"GT5  "},
  {"GT6  "},

  {"SW1  "},
  {"SW2  "},
  {"SW3  "},
  {"SW4  "},
  {"SW5  "},
  {"SW6  "},

  {"CH1  "},
  {"CH2  "},
  {"CH3  "},
  {"CH4  "},
  {"CH5  "},
  {"CH6  "},
  {"SP1  "},
  {"SP2  "}

};
// This array is 256 entries, one for each SAM sense line. For this implementation, only the SAMCHAIN1 is supported (256 SAM inputs).
const uint8_t Sense[256]={ 0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0};
const unsigned int GCMask[16] = {0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x0,0x0};
//A 0 here will cancel the corresponding SAMCHAIN1 bit. A 1 will leave it alone
// view these as a 256 bit number, LSB on the right.  Code handles the translation.

// Sense bit mask. Intended for the use of Divisionals, etc, to determine what sense lines are enabled for each piston.
// 1 in the field means the sense is active for that Piston - Corresponds to ChangedState:. First index corresponds to Piston[] assignment,second to ChangedState word
// BitMask[PistonNumber][ChangedStateWord]
// Second number is number of columns (entries in each vector).
// First number is the piston number
// The entry in the vector corresponds to the ChangedState: SAM matrix.  
// view these as a 256 bit number, LSB on the right.  Code handles the translation.
const unsigned int BitMask [40][16] = {
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},  //e.g. Piston[0] Sense mask, General
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},  //e.g. Piston[1] Sense mask.
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0xFFFF,0xFFFF},

{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},

{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},

{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},

{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0}

};



// Scanning constants and variables

// The system supports 2 chains for SAMs and 2 chains for keys. Chains 0 and 1 are SAM chains (10 pin), and chains 2 and 3 are key chains (8 pin).
// In this implementation we will only implement one SAM chain (0) and one key chain (2).
unsigned int CurrentState[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
  }; //each scan chain is 256 bits, 4 unsigned chars per scan chain. Even high byte, odd low byte
unsigned int PreviousState[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
} ; //each scan chain is 64 bits, 4 unsigned chars per scan chain. Even high byte, odd low byte. 4 chains supported
unsigned int PendingMIDIOn[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
}; // if a bit is set here, then the switch changed state
unsigned int PendingMIDIOff[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
}; // if a bit is set here, then the switch changed state
bool ChangedFlag=false;
unsigned int t32temp=0;
unsigned int OutputArray[4][16]={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
  };
int BitCounter[]={0,0,0,0};
int WordCounter[]={0,0,0,0};


int LoopDelay=100;
int test = 0;
const int MaxSAMChannels=0;
const int MaxKeyboards=0;// 4 keyboards = 256 bits.  max 8 keyboards = 512 bits.
const unsigned long bitTime=50;// in microseconds
const int frameTime=20000;// in microseconds



bool EnablePowerupLED=false;
bool PCMessageReceived=false;
const int PCMessageChannel = 1;
const int PCMessageNote=0x1;
int PCMessageLEDPort=6;
int PCMessageShutdownSwitch=5;
bool PCMessageShutdownSwitchPrevState=1;
bool PCMessageCurrentState=1; 
int SendNoteValue=0;


///////////////////////////Setup///////////////////////////

void setup() {
  usbMIDI.setHandleNoteOn(myNoteOn);
  usbMIDI.setHandleNoteOff(myNoteOff);
  Serial.begin(115200);
  Wire.begin();

  Serial.println("Setup LCD...");
//  initLCD();
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("CRControlSys");
  lcd.print(VersionNumberMajor,DEC);
  lcd.print(".");
  lcd.println(VersionNumberMinor,DEC);
  lcd.setCursor(0,1);
  lcd.print("ChrisBallantyne");  

  
  Serial.println("Setup scan chains...");
  for (int i=0;i<=1;i++){
    pinMode(SAMSense[i],INPUT_PULLUP);
    pinMode(SAMRst[i],INPUT_PULLUP);
    pinMode(SAMSync[i],OUTPUT);
    digitalWrite(SAMSync[i],LOW);
    pinMode(SAMCLK[i],OUTPUT);
    digitalWrite(SAMCLK[i],LOW);
    pinMode(SAMDrive[i],OUTPUT);
    digitalWrite(SAMDrive[i],LOW);
    
    pinMode(KeyIn[i],INPUT_PULLUP);
    pinMode(KeyOut[i],OUTPUT);
    digitalWrite(KeyOut[i],HIGH);
    pinMode(KeyRst[i],OUTPUT);
    digitalWrite(KeyRst[i],HIGH);
    delay(1);
    digitalWrite(KeyRst[i],LOW);
    delay(1);
    digitalWrite(KeyRst[i],HIGH);
    pinMode(KeyLoad[i],OUTPUT);
    digitalWrite(KeyLoad[i],HIGH);
    pinMode(KeyCLK[i],OUTPUT);
    digitalWrite(KeyCLK[i],LOW);
 
  }// for i

  Serial.println("Setup Expression...");

  if (EnableSwitchExpression){
    for (int i=0;i<=5;i++){
      pinMode(SwitchInputs[i],INPUT_PULLUP);
    }
    Serial.println("Switch pullups set");
    int j=0;
    for (int i=0; i<=5;i++){
      if (digitalRead(SwitchInputs[i])==0) j+=0x10;
    }
    PedalCurrentState[0]=j;
  }//switch expression

//  mcp.begin();
  Serial.println("Setup Expression1..");
  if(numBars>1){
    for(int j=0;j<numBars;j++){
      for (int i=0;i<=AnalogChannelSegments[j];i++){
		  barOut(j,i);
        delay(30);
      }
    }// j - initialize bars
  }// if initialize bars
  Serial.println("Setup Expression2..");



  if (EnableAnalog){
    for (int i=0;i<numAnalogChannels;i++){
//      pinMode(PedalAnalogChannel[i],INPUT);
      pinMode(PedalAnalogChannel[i],INPUT_PULLUP);
      PedalCurrentState[i]=0;
      int l=analogRead(PedalAnalogChannel[i]);
      int j=l>>AnalogDivisor;
        if (PedalCurrentState[i]>=j){
          for (int k=PedalCurrentState[i]-1; k>=j; k--){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("AnalogValueDOWN");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }//for
        }//if
        else{
          for (int k=PedalCurrentState[i]+1; k<=j; k++){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("AnalogValueUP");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }
        }//else
        PedalCurrentState[i]=j;
        Serial.print("Current State ");
        Serial.print(i);
        Serial.print(": ");
        Serial.println(PedalCurrentState[i]);
        barOut(i,0);
        BarValueF=((float) l/(float) 0x3FF);
        if (BarValueF>=0.98) barOut(i,AnalogChannelSegments[i]);
        else barOut(i,(int) (BarValueF*((float) AnalogChannelSegments[i])));
        
    }//  for i, each analog channel
  }
    Serial.println("Setup Expression3..");

    Serial.println("Setup Database..");
    for (int i=0; i<=3; i++){
      for (int j=0; j<=15; j++){
        CurrentState[i][j]=0;
        PreviousState[i][j]=0;
        PendingMIDIOff[i][j]=0xFFFF;
        PendingMIDIOn[i][j]=0;
      }
    }


/* PCMessage setup  
  pinMode(PCMessageLEDPort,OUTPUT);
  pinMode(PCMessageShutdownSwitch,INPUT_PULLUP);
*/
  pinMode(LEDStatus,OUTPUT);
  digitalWrite(LEDStatus,HIGH);


  
  Serial.println("Setup SD...");
    if (!SD.begin(chipSelect)) {
    while (1) {
      Serial.println("Unable to access the SD card");
      delay(500);
    }
  }


  Serial.println("End Setup...");
  Serial.print("Version..");
  Serial.print(VersionNumberMajor,DEC);
  Serial.print(".");
  Serial.println(VersionNumberMinor,DEC);
  Timer1.initialize(frameTime); // 10ms loop time
  Timer1.attachInterrupt(restartLoop);
  Timer1.start();

//wait for HW message here. Since SAMCHAIN1 number 256 is unused, we'll use that as the message to start
//It's MIDIChannel+1,127

  while (!PCMessageReceived){
  lcd.setCursor(0,0);
  lcd.print("Loading.........");
  if(usbMIDI.read()) {
        if((usbMIDI.getType()==0xA0)&&(usbMIDI.getChannel()==PCMessageChannel)&&(usbMIDI.getData1()==PCMessageNote)) PCMessageReceived=true;
        else {Serial.print("Type: ");Serial.print(usbMIDI.getType(),HEX);Serial.print(" CH:");Serial.print(usbMIDI.getChannel(),DEC);Serial.print(" Note:");Serial.println(usbMIDI.getData1(),DEC);}   
    }; //Look for Aftertouch (Ax) on or off on our channel
  delay(1000);
  lcd.setCursor(0,0);
  lcd.print(".........Loading");    
  delay(1000);
  }

  Serial.println("PC Message Received");

  lcd.setCursor(0,0);
  lcd.clear();
  lcd.print("Memory: ");
  lcd.print(CurrentMemoryNumber,DEC);



}//setup


///////////////////////////////////main////////////////////////////

void loop() {
  LoopCounter++;
  digitalWrite(LEDStatus,bitRead(LoopCounter,4));
//  Serial.print(".");
//  if(LoopCounter==0) Serial.print(".");

////////////////////// SCAN DATA IN  //////////////////////////////////////////

// Start of sequence strobe

for (int i=0; i<=1; i++){
  digitalWrite(SAMSync[i],HIGH);
  digitalWrite(KeyLoad[i],LOW);
}
delayMicroseconds(bitTime+bitTime);
for (int i=0;i<=1;i++){
  digitalWrite(SAMSync[i],LOW);
  digitalWrite(KeyLoad[i],HIGH);
}
delayMicroseconds(bitTime+bitTime);

if (SAMDelayCount<=0xFC) SAMDelayCount++; 

if(SAMDelayCount<=SAMDelay) {Serial.print("SAM Delay ");Serial.print(SAMDelayCount,DEC);Serial.print(" LoopCount:");Serial.println(LoopCounter,DEC);}
else {
  while(usbMIDI.read()) {}; //Look for note on or off on our channel
  for (int j=0;j<=3;j++){
    for (int i=15;i>=0;i--){
      if(PendingMIDIOn[j][i]!=0){
//          Serial.print("PendingMIDIOn[");Serial.print(j,DEC);Serial.print("][");Serial.print(i,DEC);Serial.print("]: ");Serial.print(PendingMIDIOn[j][i],HEX);Serial.print(" LoopCount:");Serial.println(LoopCounter,DEC);
          SAMDelayCount=0;
      }
      if(PendingMIDIOff[j][i]!=0xFFFF){
//          Serial.print("PendingMIDIOff[");Serial.print(j,DEC);Serial.print("][");Serial.print(i,DEC);Serial.print("]: ");Serial.print(PendingMIDIOff[j][i],HEX);Serial.print(" LoopCount:");Serial.println(LoopCounter,DEC);
          SAMDelayCount=0;
      }
      CurrentState[j][i]=CurrentState[j][i]&(PendingMIDIOff[j][i]);
      PendingMIDIOff[j][i]=0xFFFF;
      CurrentState[j][i]=CurrentState[j][i]|(PendingMIDIOn[j][i]);
      PendingMIDIOn[j][i]=0;
      }//i
  }//j
}


ChangedFlag=false;
// The loop will output the current state to the SAMDrive, and input the peripheral state from the SAMSense and KeyIn lines 
for (int i=0;i<=255;i++){
  unsigned long time=micros();
  while(micros()>=(0xFFFFFFFF-(bitTime+10))){}// If there's less than 30us left on the timer, we'll wait for the timer rollover. This prevents from having to do rollover edge conditions

  for (int j=0;j<=1;j++){
    digitalWrite(SAMDrive[j],bitRead(CurrentState[j][i>>4],(i&0xF)));
    digitalWrite(KeyOut[j],bitRead(CurrentState[j+2][i>>4],(i&0xF)));
    digitalWrite(SAMCLK[j],HIGH);
    bitWrite(CurrentState[j+2][i>>4],i&0xF,!digitalRead(KeyIn[j]));//Negative logic, a 1 on the peripheral is inactive, 0 is active
    digitalWrite(KeyCLK[j],HIGH);
    }
  delayMicroseconds((bitTime/2));
  for (int j=0;j<=1;j++){
    digitalWrite(SAMCLK[j],LOW);
    digitalWrite(KeyCLK[j],LOW);
    bitWrite(CurrentState[j][i>>4],i&0xF,!digitalRead(SAMSense[j]));//Negative logic, a 1 on the peripheral is inactive, 0 is active
    if (SAMChainsSupported==1&&j==1) CurrentState[j][i>>4]=0; // with CA support only 1 SAM chain initially
  }//j
  
  while((micros()-time)<bitTime){}
}//i

////////////////////////// END SCAN DATA IN ///////////////////////////


//////////////////////////////////// ANALOG CHANNELS ///////////////////////////////////////////////////////

/* Switch Expression
if (EnableSwitchExpression){
  int i=0;
  int j=0;
  for (int k=0; k<=5;k++){
    //debug
    pinMode(SwitchInputs[i],INPUT_PULLUP);
  //!debug
    if (digitalRead(SwitchInputs[k])==0) {j+=0x10; Serial.print("Switch number: ");Serial.println(k);}
  }
  if (j!=PedalCurrentState[i])
    {
      if (PedalCurrentState[i]>=j)
      {
        for (int k=PedalCurrentState[i]-1; k>=j; k--)
        {
          usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
    Serial.print("SwitchValue");
    Serial.println(j,HEX);
        }
      }
      else
      {
        for (int k=PedalCurrentState[i]+1; k<=j; k++)
        {
          usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
    Serial.print("SwitchValue");
    Serial.println(j);
        }
      }
      PedalCurrentState[i]=j;
      Serial.print("Current State ");
      Serial.print(i);
      Serial.print(": ");
      Serial.println(PedalCurrentState[i]);
    }
} //switch expression
*/




///////////////////////// Scan analog channels /////////////////////////////


  if (EnableAnalog){
    for (int i=0;i<numAnalogChannels;i++){
      int AnalogReadChannel=i;
      if (bitRead(CurrentState[AllSwells>>8][(AllSwells&0xF0)>>4],AllSwells-(AllSwells>>4)*16)==1) AnalogReadChannel=AllSwellsChannel;
      int l=(analogRead(PedalAnalogChannel[AnalogReadChannel]));
      int j=l>>AnalogDivisor;
      if (j!=PedalCurrentState[i]){
        if (PedalCurrentState[i]>=j){
          for (int k=PedalCurrentState[i]-1; k>=j; k--){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("Pedal ");
            Serial.print(i);
            Serial.print(" AnalogValueDOWN");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }//for
        }//if
        else{
          for (int k=PedalCurrentState[i]+1; k<=j; k++){
            usbMIDI.sendControlChange(PedalCCValue[i],k,MIDIChannel);
            Serial.print("Pedal ");
            Serial.print(i);
            Serial.print(" AnalogValueUP");
            Serial.print(j);
            Serial.print(" CCValue:");
            Serial.println(k);
          }
        }//else
        PedalCurrentState[i]=j;
        Serial.print("Current State ");
        Serial.print(i);
        Serial.print(": ");
        Serial.println(PedalCurrentState[i]);

        BarValueF=((float) l/(float) 0x3FF);
        if (BarValueF>=0.98) barOut(i,AnalogChannelSegments[i]);
        else {
        barOut(i,(int) (BarValueF*((float) AnalogChannelSegments[i])));
        Serial.print("BarValue: ");
        Serial.print(BarValueF);
        Serial.println((int) BarValueF,DEC);
        Serial.print("BarValueint: ");
        Serial.print((int) (BarValueF*((float) AnalogChannelSegments[i])));
        }
      }// if j!=
    }//  for i, each analog channel
  }
////////////////////////////////analog channel/



//////////////////////////////  COMBINATION ACTION MEMORY  //////////////////////////////////////////

SpecialPistonState=false;   
PistonChangedFlag=false;

for (int j=0;j<=3;j++) for (int i=0;i<=15;i++) OutputArray[j][i]=0;
// if changed and mem+==0, memorylevel++ to 255
if (
  ((bitRead(CurrentState[MemPlusButton>>8][(MemPlusButton&0xF0)>>4],MemPlusButton-(MemPlusButton>>4)*16)==1)&&(bitRead(PreviousState[MemPlusButton>>8][(MemPlusButton&0xF0)>>4],MemPlusButton-(MemPlusButton>>4)*16)==0))
  |(bitRead(CurrentState[MemPlusButton2>>8][(MemPlusButton2&0xF0)>>4],MemPlusButton2-(MemPlusButton2>>4)*16)==1)&&(bitRead(PreviousState[MemPlusButton2>>8][(MemPlusButton2&0xF0)>>4],MemPlusButton2-(MemPlusButton2>>4)*16)==0)

){
  if (CurrentMemoryNumber<=0xFFE) {
	  CurrentMemoryNumber++;
	  // Write current memory number to LCD
	  lcd.setCursor(0,0);
      lcd.print("Memory: ");
      lcd.print(CurrentMemoryNumber,DEC);
    }
  SpecialPistonState=true;
}
// if changed and mem-==0, memorylevel-- to 0
if (
  ((bitRead(CurrentState[MemMinusButton>>8][(MemMinusButton&0xF0)>>4],MemMinusButton-(MemMinusButton>>4)*16)==1)&&(bitRead(PreviousState[MemMinusButton>>8][(MemMinusButton&0xF0)>>4],MemMinusButton-(MemMinusButton>>4)*16)==0))
  |(bitRead(CurrentState[MemMinusButton2>>8][(MemMinusButton2&0xF0)>>4],MemMinusButton2-(MemMinusButton2>>4)*16)==1)&&(bitRead(PreviousState[MemMinusButton2>>8][(MemMinusButton2&0xF0)>>4],MemMinusButton2-(MemMinusButton2>>4)*16)==0)

)
{
  if (CurrentMemoryNumber>=1) {
	  CurrentMemoryNumber--;
	  // Write current memory number to LCD
	  lcd.setCursor(0,0);
      lcd.print("Memory: ");
      lcd.print(CurrentMemoryNumber,DEC);
  }
  SpecialPistonState=true;
}

  
// check for set
if ((bitRead(CurrentState[SetButton>>8][(SetButton&0xF0)>>4],SetButton-(SetButton>>4)*16)==1)) {SetState=true;Serial.println("set");lcd.setCursor(13,1);lcd.print("SET");} 
else SetState=false; ///Note: SET is level, not edge sensitive
if (
  (bitRead(CurrentState[SetButton>>8][(SetButton&0xF0)>>4],SetButton-(SetButton>>4)*16)==0)
  &&
  (bitRead(PreviousState[SetButton>>8][(SetButton&0xF0)>>4],SetButton-(SetButton>>4)*16)==1)
  ) 
  {lcd.setCursor(13,1);lcd.print("   ");} 

// check for GCButton
if ((bitRead(CurrentState[GCButton>>8][(GCButton&0xF0)>>4],GCButton-(SetButton>>4)*16)==1)) {
  GCState=true;
  SpecialPistonState=true;
  Serial.println("GC");lcd.setCursor(13,1);lcd.print("GC ");
  PistonChangedFlag=true;
}
else GCState=false; ///Note: GC is level, not edge sensitive
if ((bitRead(CurrentState[GCButton>>8][(GCButton&0xF0)>>4],GCButton-(GCButton>>4)*16)==0)&&(bitRead(PreviousState[GCButton>>8][(GCButton&0xF0)>>4],GCButton-(GCButton>>4)*16)==1)) {lcd.setCursor(13,1);lcd.print("   ");} 



// check for previous and next.  If previous or next, then set the appropriate Current State bit corresponding to virtually pressed button
for (int i=0;i<=3;i++){
    ProcIndex=(NextButton[i]>>4)&0xF;
    ProcBit=NextButton[i]-(NextButton[i]>>4)*16;
    ProcArray=(NextButton[i]&0xF00)>>8;
    if ((bitRead(PreviousState[ProcArray][ProcIndex],ProcBit)==0)&&(bitRead(CurrentState[ProcArray][ProcIndex],ProcBit)==1)){
      CurrentPistonNumber++;
      SpecialPistonState=true;
		  if (CurrentMemoryNumber<=0xFFE&&CurrentPistonNumber==MaxPistonNumber) {
        CurrentMemoryNumber++;
        CurrentPistonNumber=0;
        // Write current memory number to LCD
        lcd.setCursor(0,0);
        lcd.print("Memory: ");
        lcd.print(CurrentMemoryNumber,DEC);
      }
      else{
        if(CurrentPistonNumber==MaxPistonNumber&&CurrentMemoryNumber==0xFFF){
          CurrentPistonNumber--;
        }
      }
      // we know what memory and what piston we are on now.  Now set the bit based on CurrentPistonNumber in OutputArray
      PistonChangedFlag=true;
      ProcIndex=(Piston[SequencerPistonList[CurrentPistonNumber]]>>4)&0xF;
      ProcBit=Piston[SequencerPistonList[CurrentPistonNumber]]-(Piston[SequencerPistonList[CurrentPistonNumber]]>>4)*16;
      ProcArray=(Piston[SequencerPistonList[CurrentPistonNumber]]&0xF00)>>8;
      bitSet(OutputArray[ProcArray][ProcIndex],ProcBit);
    }

    ProcIndex=(PrevButton[i]>>4)&0xF;
    ProcBit=PrevButton[i]-(PrevButton[i]>>4)*16;
    ProcArray=(PrevButton[i]&0xF00)>>8;
    if ((bitRead(PreviousState[ProcArray][ProcIndex],ProcBit)==0)&&(bitRead(CurrentState[ProcArray][ProcIndex],ProcBit)==1)){
      CurrentPistonNumber--;
      SpecialPistonState=true;
      if (CurrentMemoryNumber>=1&&CurrentPistonNumber==-1) {
        CurrentMemoryNumber--;
        CurrentPistonNumber=(MaxPistonNumber-1);
        // Write current memory number to LCD
        lcd.setCursor(0,0);
        lcd.print("Memory: ");
        lcd.print(CurrentMemoryNumber,DEC);
      }
      else{
        if(CurrentPistonNumber==-1&&CurrentMemoryNumber==0){
          CurrentPistonNumber=0;         
        }
      }
      // we know what memory and what piston we are on now.  Now set the bit based on CurrentPistonNumber in OutputArray
      PistonChangedFlag=true;
      ProcIndex=(Piston[SequencerPistonList[CurrentPistonNumber]]>>4)&0xF;
      ProcBit=Piston[SequencerPistonList[CurrentPistonNumber]]-(Piston[SequencerPistonList[CurrentPistonNumber]]>>4)*16;
      ProcArray=(Piston[SequencerPistonList[CurrentPistonNumber]]&0xF00)>>8;
      bitSet(OutputArray[ProcArray][ProcIndex],ProcBit);
    }


	}//next i, next and previous buttons
	
	


if (!SpecialPistonState){
	
for (int i=0;i<=39;i++){
  if (Piston[i]!=0x400){
    ProcIndex=(Piston[i]>>4)&0xF;
    ProcBit=Piston[i]-(Piston[i]>>4)*16;
    ProcArray=(Piston[i]&0xF00)>>8;
    if ((bitRead(PreviousState[ProcArray][ProcIndex],ProcBit)==0)&&(bitRead(CurrentState[ProcArray][ProcIndex],ProcBit)==1)){
      // generate filename
      Serial.print("pushed Piston ");Serial.println(i);
      PistonChangedFlag=true;
      PressedPiston=i;
      lcd.setCursor(0,1);
      for(int k=0;k<=4;k++){
        lcd.print(PistonName[i][k]);
      }
      String PistonFilename = "A00";//A for piston, 00 reserved.  
      if (CurrentMemoryNumber<=0xFF) PistonFilename=PistonFilename+"0";//support 0xFFF memories (8192)
      if (CurrentMemoryNumber<=0xF) PistonFilename=PistonFilename+"0";
      PistonFilename=PistonFilename+String(CurrentMemoryNumber,HEX);
	  Serial.print("Memory Level: ");Serial.println(CurrentMemoryNumber,HEX);

// Write current memory number to LCD
  lcd.setCursor(0,0);
  lcd.print("Memory: ");
  lcd.print(CurrentMemoryNumber,DEC);

      if (i<=0xF) PistonFilename=PistonFilename+"0";
      PistonFilename=PistonFilename+String(i,HEX);
      Serial.print("PistonFilename: ");
      Serial.println(PistonFilename);

//At this point we have the piston filename , regardless of the SET.

      
      // Create file if it doesn't exist
      if (!SD.exists(PistonFilename.c_str())){
        Serial.print("Create File "); Serial.println(PistonFilename);
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
        pistonFile.close();
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
        pistonFile.print("0000000000000000000000000000000000000000000000000000000000000000");// Format is 256 bits, or 64 nibbles (characters - bits per). For the implementation, we will only support 256 SAMs
        pistonFile.close();
      }

      if (SetState){
        SD.remove(PistonFilename.c_str());
    		pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);
        pistonFile.close();
        pistonFile=SD.open(PistonFilename.c_str(),FILE_WRITE);

        for (int j=15;j>=0;j--){
            Serial.print("BuildOutputArray " );Serial.print(i);Serial.println(j);printint16(CurrentState[0][j]);Serial.print("&");printint16(BitMask[i][15-j]);Serial.println("");
            OutputArray[0][j]=(CurrentState[0][j])&(BitMask[i][15-j]);//Stores 0's, which are active, as 1's. Note that we only support chain 0, which is SAMCHAIN1.
            PistonChangedFlag=true;
            switch (OutputArray[0][j]){
              case 0:
                pistonFile.print("0000");Serial.print("0000");
                break;
              case 1 ... 0xF:
                pistonFile.print("000");pistonFile.print(OutputArray[0][j],HEX);Serial.print("000");Serial.print(OutputArray[0][j],HEX);
                break;
              case 0x10 ... 0xFF:
                pistonFile.print("00");pistonFile.print(OutputArray[0][j],HEX);Serial.print("00");Serial.print(OutputArray[0][j],HEX);
                break;
              case 0x100 ... 0xFFF:
                pistonFile.print("0");pistonFile.print(OutputArray[0][j],HEX);Serial.print("0");Serial.print(OutputArray[0][j],HEX);
                break;
              case 0x1000 ... 0xFFFF:
                pistonFile.print(OutputArray[0][j],HEX);Serial.print(OutputArray[0][j],HEX);
                break;
            }
            
            
        }
        Serial.print("Set Piston[");Serial.print(i,DEC);Serial.print("]: ");for(int testi=0;testi<=7;testi++) printint16(OutputArray[0][testi]);Serial.println("");
        NewPistonSet=true;
        
       } //SetStatus
       else // not set status
       {
    			pistonFile=SD.open(PistonFilename.c_str());

		// read file, convert HEX to numbers and write to tTempArray[].  Build OutputArray[], which gets applied to CurrentState after it's written to PreviousState so that changes get applied on next cycle
          tTempString="";
          while (pistonFile.available()) {
            switch (pistonFile.read()){
            case 48:
              tTempString=tTempString+"0";
              break;
            case 49:
              tTempString=tTempString+"1";
              break;
            case 50:
              tTempString=tTempString+"2";
              break;
            case 51:
              tTempString=tTempString+"3";
              break;
            case 52:
              tTempString=tTempString+"4";
              break;
            case 53:
              tTempString=tTempString+"5";
              break;
            case 54:
              tTempString=tTempString+"6";
              break;
            case 55:
              tTempString=tTempString+"7";
              break;
            case 56:
              tTempString=tTempString+"8";
              break;
            case 57:
              tTempString=tTempString+"9";
              break;
            case 65:
              tTempString=tTempString+"A";
              break;
            case 66:
              tTempString=tTempString+"B";
              break;
            case 67:
              tTempString=tTempString+"C";
              break;
            case 68:
              tTempString=tTempString+"D";
              break;
            case 69:
              tTempString=tTempString+"E";
              break;
            case 70:
              tTempString=tTempString+"F";
              break;
          }//switch
//          Serial.println(tTempString);
          }//while file
          Serial.print("String Read from ");Serial.print(pistonFile);Serial.print(": ");Serial.println(tTempString);
          for (int j=15;j>=0;j--){
			Serial.print("j=");Serial.print(j);Serial.print("::");
            OutputArray[0][j]=t16Stringtoint(tTempString.substring(j*4,j*4+4));//Set the CurrentState of SAMCHAIN1, after PREVIOUS state is reset.
            Serial.print("OutputArray[0][");Serial.print(j,DEC);Serial.print("]: ");Serial.println(OutputArray[0][j],HEX);
          }

            
            
	   } //Not Set Status    
            
        pistonFile.close();

        
        
      }//if piston changed
    }//if piston !=0
  }//for i
}//!GCstate && !SetState

////////////////////////////////// END COMBINATION ACTION













 
    
//////////////////////////PCSwitch

  PCMessageCurrentState=digitalRead(PCMessageShutdownSwitch);   
  if (PCMessageCurrentState!=PCMessageShutdownSwitchPrevState){
    if (PCMessageCurrentState==0) usbMIDI.sendNoteOn(PCMessageNote,0x7F,PCMessageChannel); else usbMIDI.sendNoteOff(PCMessageNote,0x7F,PCMessageChannel);
    PCMessageShutdownSwitchPrevState=PCMessageCurrentState;
  }

  if(EnablePowerupLED){
    if(!PCMessageReceived)
      digitalWrite(PCMessageLEDPort,bitRead(LoopCounter,6));
    else
      digitalWrite(PCMessageLEDPort,1);
  
    
  }








//////////////////////////// Send out if changed, Previous=Changed //////////////////////////////////
for (int i=0;i<=15;i++){
  for (int j=0;j<=3;j++){
    if(CurrentState[j][i]!=PreviousState[j][i])
      ChangedFlag=true;
  }//j
}//i

if (ChangedFlag){
  for (int j=0;j<=3;j++){
    Serial.print("MSW first PreviousState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(PreviousState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
}//changed


if (ChangedFlag){
for (int i=0;i<=255;i++){
  for (int j=0;j<=3;j++){
    int currentstateflag=bitRead(CurrentState[j][i>>4],i&0xF);
    int previousstateflag=bitRead(PreviousState[j][i>>4],i&0xF);
    if(currentstateflag!=previousstateflag){
      SAMDelayCount=0;
      int MIDICHOut=MIDIChannel+2*j;
      int NoteNumber=NoteBase+127-i;
      if (bitRead(i,7)==HIGH) {MIDICHOut++; NoteNumber=NoteNumber+128;}
      if (currentstateflag) {usbMIDI.sendNoteOn(NoteNumber,0x7F,MIDICHOut);Serial.print("Send Note ON:");} 
      else  {usbMIDI.sendNoteOff(NoteNumber,0x7F,MIDICHOut);;Serial.print("Send Note OFF:");}
      Serial.print(NoteNumber,DEC);
      Serial.print(" CH:");
      Serial.println(MIDICHOut,DEC);
    }
    bitWrite(PreviousState[j][i>>4],i&0xF,currentstateflag);
  }//j
}//i

/* if (ChangedFlag){
  Serial.println("State after processing ChangedState:");
  for (int j=0;j<=3;j++){
    Serial.print("MSW first CurrentState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(CurrentState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
  for (int j=0;j<=3;j++){
    Serial.print("MSW first PreviousState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(PreviousState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
}//changed
*/
}//ChangedFlag


if (PistonChangedFlag){
  for (int i=1;i<=3;i++) for (int j=0;j<=15;j++) CurrentState[i][j]=CurrentState[i][j]|OutputArray[i][j];
    for (int i=0;i<=15;i++){
      if (GCState) CurrentState[0][i]=CurrentState[0][i]&GCMask[15-i];
      else {
        if(!NewPistonSet){
        CurrentState[0][i]=CurrentState[0][i]&(!BitMask[PressedPiston][15-i]);
        CurrentState[0][i]=CurrentState[0][i]|OutputArray[0][15-i];
        }
        else
        NewPistonSet=false;
      }
      
    }//i
  Serial.println("State after processing ChangedState:");
  for (int j=0;j<=3;j++){
    Serial.print("PISTON MSW first CurrentState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(CurrentState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j
  for (int j=0;j<=3;j++){
    Serial.print("PISTON MSW first PreviousState[");
    Serial.print(j);
    Serial.print("]:  ");
    for (int i=15;i>=0;i--){
      Serial.print(PreviousState[j][i],HEX);
      Serial.print(" ");
      }//i
    Serial.println(" ");
  }//j


  }//PistonChangedFlag




//////////////////////////// Wait for loop interrupt ////////////////////////
  LoopDone=true;
//  Serial.print(micros());
  while(IsLoopDone()){
    delay(1); //why adding this in makes it work is beyond me.
    }
    LoopDone=true;
  
}// void loop()



void printint16(unsigned int printvalue){
  if (printvalue<0xF) {Serial.print("000");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  if (printvalue<0xFF) {Serial.print("00");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  if (printvalue<0xFFF) {Serial.print("0");Serial.print(printvalue,HEX);Serial.print(" ");return;}
  Serial.print(printvalue,HEX); Serial.print(" ");
  return;
  
}



void barOut(int address,int numsegments){
  int sendval=1;
  if (numsegments==0) {
    barSetup(address,0);
    return;
  }
  if (numsegments==1) 
    barSetup(address,1);
  else{
    for (int i=0;i<(numsegments-1);i++){
      sendval=(sendval<<1)|1;
    }
    barSetup(address,sendval);
  }
}

void barSetup(int address, int GPValue){
//  I2CWrite(address+0x20,0x15,0);// IOCON=0, Bank 0. Reset state is bank 0
  I2CWrite(address+0x20,0x0,0);// IODIRA=0, all outputs
  I2CWrite(address+0x20,0x1,0xFC);// IODIRB=FC, low 2 bits outputs
  I2CWrite(address+0x20,0x12,GPValue&0xFF);// GPIOA
  I2CWrite(address+0x20,0x13,GPValue>>8);// GPIO Bank0 = 0xFC -> Bits 0 and 1 outputs
}

void I2CWrite(int I2CAddress, int RegAddress, int Data){
  Wire.beginTransmission(I2CAddress);
  Wire.write(RegAddress); // IOCON
  Wire.write(Data); //IOCON=0
  Wire.endTransmission();
}


/*
void barOut(int address,int numsegments){
  if (numsegments==0) {
  for (int i=0;i<=9;i++) mcp.digitalWrite(i+address*8,LOW);
    return;
  }
  for (int i=0;i<numsegments;i++) mcp.digitalWrite(i+address*8,HIGH);   
  for (int i=numsegments;i<=numsegments;i++) mcp.digitalWrite(i+address*8,LOW);
}
*/

unsigned int t16Stringtoint(String inString){
  unsigned int ReturnValue=0;
  unsigned int AddValue=0;
  Serial.print("inString = ");Serial.println(inString);
  for (int qi=0; qi<=3; qi++){
    switch (inString.charAt(qi)){
      case '0':
        AddValue=0;
        break;
      case '1':
        AddValue=1;
        break;
      case '2':
        AddValue=2;
        break;
      case '3':
        AddValue=3;
        break;
      case '4':
        AddValue=4;
        break;
      case '5':
        AddValue=5;
        break;
      case '6':
        AddValue=6;
        break;
      case '7':
        AddValue=7;
        break;
      case '8':
        AddValue=8;
        break;
      case '9':
        AddValue=9;
        break;
      case 'A':
        AddValue=10;
        break;
      case 'B':
        AddValue=11;
        break;
      case 'C':
        AddValue=12;
        break;
      case 'D':
        AddValue=13;
        break;
      case 'E':
        AddValue=14;
        break;
      case 'F':
        AddValue=15;
        break;
        
    }//switch
    AddValue=AddValue<<(4*(3-qi));
    ReturnValue=ReturnValue|AddValue;
//    Serial.print(inString.charAt(qi));Serial.print(" ");Serial.print(qi);Serial.print(" "); Serial.println(ReturnValue,HEX);    
  }//for
  return ReturnValue;
}//function



void restartLoop(){
  LoopDone=false;
//  Serial.println(millis());
//  Serial.print("TimerDone ");
//  Serial.println(LoopDone);
}

bool IsLoopDone(){
  return LoopDone;
}
  
void myNoteOff(byte channel, byte note, byte velocity)
{
  Serial.print("External Note Off, ch=");
  Serial.print(channel, DEC);
  Serial.print(", note=");
  Serial.print(note, DEC);
  Serial.print(", velocity=");
  Serial.println(velocity, DEC);
  if((channel>=MIDIChannel)&&(channel<=(MIDIChannel+3)))
  {
    Serial.print("Message for me...LoopCount: ");
    Serial.println(LoopCounter,DEC);
    int index=(channel-MIDIChannel)>>1;
    int wordno=(((channel-MIDIChannel)&0x01)<<5)|((note&0x70)>>4);
    int bitno=note&0x0F;
    bitClear(PendingMIDIOff[index][wordno],bitno);

   }

}

void myNoteOn(byte channel, byte note, byte velocity) {
  Serial.print("ExternalNote On, ch=");
  Serial.print(channel, DEC);
  Serial.print(", note=");
  Serial.print(note, DEC);
  Serial.print(", velocity=");
  Serial.println(velocity, DEC);
  
  if((channel>=MIDIChannel)&&(channel<=(MIDIChannel+3)))
  {
    Serial.print("Message for me...LoopCount: ");
    Serial.println(LoopCounter,DEC);
    int index=(channel-MIDIChannel)>>1;
    int wordno=(((channel-MIDIChannel)&0x01)<<5)|((note&0x70)>>4);
    int bitno=note&0x0F;
    bitSet(PendingMIDIOn[index][wordno],bitno);

  }
  if(channel==PCMessageChannel){
    if (note==PCMessageNote) {PCMessageReceived=true;}  
  }
}
 
